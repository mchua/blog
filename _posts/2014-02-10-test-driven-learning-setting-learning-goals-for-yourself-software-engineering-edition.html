---
layout: post
title: 'Test Driven Learning: setting learning goals for yourself, Software Engineering
  edition'
date: 2014-02-10 22:01:20.000000000 -05:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- engineering edu
- teaching open source
- testing
- women in free software
tags:
- hackerschool
meta:
  _jd_tweet_this: 'yes'
  aktt_tweeted: '1'
  _edit_last: '2'
  _stcr@_eternaljaguar915@gmail.com: 2014-02-17 17:31:44|Y
  _wpt_failed: 'a:5:{s:6:"author";b:0;s:8:"sentence";s:115:"Blog: Test Driven Learning:
    setting learning goals for yourself, Software Engineering edition http://bit.ly/1iJ03ZT";s:5:"error";s:303:"403
    Forbidden: The request is understood, but it has been refused. This code is used
    when requests are understood, but are denied by Twitter. Reasons can include:
    Too many Tweets created in a short time or the same Tweet was submitted twice
    in a row, among others. This is not an error by WP to Twitter.";s:4:"code";i:403;s:9:"timestamp";i:1392087684;}'
  _wp_jd_bitly: http://bit.ly/1iJ03ZT
  _stcr@_tori@tickviking.com: 2014-02-16 00:24:54|Y
  _wp_jd_target: http://blog.melchua.com/2014/02/10/test-driven-learning-setting-learning-goals-for-yourself-software-engineering-edition/
author:
  login: mchua
  email: mel@melchua.com
  display_name: Mel
  first_name: Mel
  last_name: Chua
---
<p>Stacey asked me for a refresher on Test Driven Learning for <a href="http://hackerschool.com">Hacker Schoo</a>l, so here we go.</p>
<p>Test Driven Learning is a software engineer's articulation of Wiggin &amp; McTighe's <a href="http://en.wikipedia.org/wiki/Understanding_by_Design">Understanding by Design</a> framework after being strongly influenced by <a href="http://ruthstreveler.wordpress.com/">Ruth Streveler's</a> "Curriculum, Assessment, and Pedagogy" course at Purdue.</p>
<p>Many software engineers are familiar with the process of <a href="http://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development (TDD)</a>.</p>
<ol>
<li>Decide on the goal.</li>
<li>Write the test ("how will you know if it's working, exactly?")</li>
<li>Make the code pass the test.</li>
<li>Celebrate.</li>
</ol>
<p>&nbsp;</p>
<p>Test Driven Learning (TDL) simply says "it's the same thing... for your brainnnnn!"</p>
<ol>
<li>Decide on the goal ("learning objective").</li>
<li>Design the assessment ("how will you know if you've learned it, exactly?")</li>
<li>Go through the experiences/etc. you need to pass your assessment.</li>
<li>Celebrate.</li>
</ol>
<p>&nbsp;</p>
<p>That's it. Really.</p>
<p>Step 2 is the part most people flub. With software tests, you have a compiler/interpreter forcing you to be precise. With learning assessments, you don't -- but you need <em>exactly</em> the same level of precision and external execution. If you asked a group of external people (with appropriate expertise) whether you'd passed the assessment you set for yourself, there should be <em>no disagreement</em>. If there's disagreement, your assessment needs a redesign.</p>
<p>A good assessment is a goal that helps you stretch and reach it; sometimes it encourages you to do more. But sometimes it also gives you permission to <em>stop doing stuff</em> -- you've written the code, you've delivered the talk, they met the criteria you set --  and now you're <em>done. </em>You can absolutely set a new goal up and keep on learning. However, you're no longer allowed to say you Haven't Learned X, because you've just proven that you have.</p>
<p>Here are some rough-draft quality TDL assessments you might start with, and a bit of how you might improve them.</p>
<p><strong>I will learn Python.</strong> (What does that even mean? How will you know you've learned it?) I will complete and pass any 50 <a href="http://codingbat.com/python">CodingBat</a> exercises in Python. (But I could do that by solving 50 really easy problems.) Only 10 of those 50 problems can be warm-ups, and at least 20 of them must be Medium difficulty or greater. (Does it matter if you get help with the problems?) Nope, I can get as much help as I want from anyone, as long as I could explain the final solution to another programmer.</p>
<p><strong>I will get better at testing.</strong> (What do you mean by "testing"?) I write a lot of code, but I've never written tests for any of it. I hear the <a href="https://nose.readthedocs.org/en/latest/">nose</a> framework is nice. (What do you mean by "better"?) Well, I've never written a test at all, so even going from 0 to 1 would be an improvement. I could use nose to write tests for 3 different pieces of working code I've already written. (Do these need to be big or exhaustive tests?) Nope, I'm just trying to learn what writing tests is like, not get full test coverage on my code... at least not yet. Even if I write a 3-line test that checks out one minor function, it counts as one of the 3 tests. (What does it mean for a test to be "done"?) When someone else can check out and successfully run my code and my test suite on their computer without needing to modify either bit of code, it's done.</p>
<p><strong>I will understand how databases work.</strong> (By "understand," do you mean the mathematical theory behind their design? Or how to actually implement and use one?) Oh geez, the latter. I don't care about the math so long as I know how to interface with a database. Any sort of database. (So you need to make a demo.) Yeah, but that's not enough; I can blindly type in code from a tutorial, but that doesn't mean I'd be able to field questions on it. (What could you do about that?) I will give a presentation to fellow Hacker Schoolers demonstrating a small database interaction in code I have written. That's an easy binary to check; either I've given the presentation or I haven't.</p>
<p>Thoughts, questions, ideas? Got your own example TDL assessment (at any stage of revision), or ways to improve the ones above? Holler in the comments.</p>
